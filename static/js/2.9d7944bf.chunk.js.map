{"version":3,"sources":["../node_modules/react-infinite-scroll-component/dist/index.es.js","components/Lazy_load.jsx"],"names":["_extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","_assign","assign","t","s","i","n","arguments","length","prototype","call","apply","this","ThresholdUnits","Pixel","Percent","defaultThreshold","unit","value","parseThreshold","scrollThreshold","match","parseFloat","console","warn","index_es","_super","InfiniteScroll","props","_this","lastScrollTop","actionTriggered","startY","currentY","dragging","maxPullDownDistance","getScrollableTarget","scrollableTarget","HTMLElement","document","getElementById","onStart","evt","MouseEvent","pageY","TouchEvent","touches","_infScroll","style","willChange","transition","onMove","Number","pullDownToRefreshThreshold","setState","pullToRefreshThresholdBreached","overflow","transform","onEnd","state","refreshFunction","requestAnimationFrame","onScrollListener","event","onScroll","setTimeout","target","height","_scrollableNode","documentElement","scrollTop","body","inverse","isElementAtTop","isElementAtBottom","hasMore","showLoader","next","prevDataLength","dataLength","throttledOnScrollListener","delay","noTrailing","callback","debounceMode","timeoutID","cancelled","lastExec","clearExistingTimeout","clearTimeout","wrapper","self","elapsed","Date","now","args","exec","undefined","cancel","throttle","bind","__","constructor","create","__extends","componentDidMount","Error","el","window","addEventListener","initialScrollY","scrollHeight","scrollTo","pullDownToRefresh","_pullDown","firstChild","getBoundingClientRect","forceUpdate","componentWillUnmount","removeEventListener","componentDidUpdate","prevProps","getDerivedStateFromProps","nextProps","prevState","clientHeight","screen","availHeight","threshold","render","WebkitOverflowScrolling","hasChildren","children","outerDivStyle","react_default","a","createElement","className","ref","infScroll","position","pullDown","left","right","top","releaseToRefreshContent","pullDownToRefreshContent","loader","endMessage","react","Lazy_load","_useState","useState","from","_useState2","slicedToArray","items","setItems","border","margin","padding","id","overflowY","concat","scrollableDiv","map","index","key"],"mappings":"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","file":"static/js/2.9d7944bf.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return _extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return _assign.apply(this, arguments);\n};\n\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset)\n * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @return {Function}  A new, throttled, function.\n */\nfunction throttle(delay, noTrailing, callback, debounceMode) {\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n  function cancel() {\n    clearExistingTimeout();\n    cancelled = true;\n  } // `noTrailing` defaults to falsy.\n\n  if (typeof noTrailing !== 'boolean') {\n    debounceMode = callback;\n    callback = noTrailing;\n    noTrailing = undefined;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n  function wrapper() {\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n    var args = arguments;\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, args);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n    function clear() {\n      timeoutID = undefined;\n    }\n    if (debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`.\n       */\n      exec();\n    }\n    clearExistingTimeout();\n    if (debounceMode === undefined && elapsed > delay) {\n      /*\n       * In throttle mode, if `delay` time has been exceeded, execute\n       * `callback`.\n       */\n      exec();\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\nvar ThresholdUnits = {\n  Pixel: 'Pixel',\n  Percent: 'Percent'\n};\nvar defaultThreshold = {\n  unit: ThresholdUnits.Percent,\n  value: 0.8\n};\nfunction parseThreshold(scrollThreshold) {\n  if (typeof scrollThreshold === 'number') {\n    return {\n      unit: ThresholdUnits.Percent,\n      value: scrollThreshold * 100\n    };\n  }\n  if (typeof scrollThreshold === 'string') {\n    if (scrollThreshold.match(/^(\\d*(\\.\\d+)?)px$/)) {\n      return {\n        unit: ThresholdUnits.Pixel,\n        value: parseFloat(scrollThreshold)\n      };\n    }\n    if (scrollThreshold.match(/^(\\d*(\\.\\d+)?)%$/)) {\n      return {\n        unit: ThresholdUnits.Percent,\n        value: parseFloat(scrollThreshold)\n      };\n    }\n    console.warn('scrollThreshold format is invalid. Valid formats: \"120px\", \"50%\"...');\n    return defaultThreshold;\n  }\n  console.warn('scrollThreshold should be string or number');\n  return defaultThreshold;\n}\nvar InfiniteScroll = /** @class */function (_super) {\n  __extends(InfiniteScroll, _super);\n  function InfiniteScroll(props) {\n    var _this = _super.call(this, props) || this;\n    _this.lastScrollTop = 0;\n    _this.actionTriggered = false;\n    // variables to keep track of pull down behaviour\n    _this.startY = 0;\n    _this.currentY = 0;\n    _this.dragging = false;\n    // will be populated in componentDidMount\n    // based on the height of the pull down element\n    _this.maxPullDownDistance = 0;\n    _this.getScrollableTarget = function () {\n      if (_this.props.scrollableTarget instanceof HTMLElement) return _this.props.scrollableTarget;\n      if (typeof _this.props.scrollableTarget === 'string') {\n        return document.getElementById(_this.props.scrollableTarget);\n      }\n      if (_this.props.scrollableTarget === null) {\n        console.warn(\"You are trying to pass scrollableTarget but it is null. This might\\n        happen because the element may not have been added to DOM yet.\\n        See https://github.com/ankeetmaini/react-infinite-scroll-component/issues/59 for more info.\\n      \");\n      }\n      return null;\n    };\n    _this.onStart = function (evt) {\n      if (_this.lastScrollTop) return;\n      _this.dragging = true;\n      if (evt instanceof MouseEvent) {\n        _this.startY = evt.pageY;\n      } else if (evt instanceof TouchEvent) {\n        _this.startY = evt.touches[0].pageY;\n      }\n      _this.currentY = _this.startY;\n      if (_this._infScroll) {\n        _this._infScroll.style.willChange = 'transform';\n        _this._infScroll.style.transition = \"transform 0.2s cubic-bezier(0,0,0.31,1)\";\n      }\n    };\n    _this.onMove = function (evt) {\n      if (!_this.dragging) return;\n      if (evt instanceof MouseEvent) {\n        _this.currentY = evt.pageY;\n      } else if (evt instanceof TouchEvent) {\n        _this.currentY = evt.touches[0].pageY;\n      }\n      // user is scrolling down to up\n      if (_this.currentY < _this.startY) return;\n      if (_this.currentY - _this.startY >= Number(_this.props.pullDownToRefreshThreshold)) {\n        _this.setState({\n          pullToRefreshThresholdBreached: true\n        });\n      }\n      // so you can drag upto 1.5 times of the maxPullDownDistance\n      if (_this.currentY - _this.startY > _this.maxPullDownDistance * 1.5) return;\n      if (_this._infScroll) {\n        _this._infScroll.style.overflow = 'visible';\n        _this._infScroll.style.transform = \"translate3d(0px, \" + (_this.currentY - _this.startY) + \"px, 0px)\";\n      }\n    };\n    _this.onEnd = function () {\n      _this.startY = 0;\n      _this.currentY = 0;\n      _this.dragging = false;\n      if (_this.state.pullToRefreshThresholdBreached) {\n        _this.props.refreshFunction && _this.props.refreshFunction();\n        _this.setState({\n          pullToRefreshThresholdBreached: false\n        });\n      }\n      requestAnimationFrame(function () {\n        // this._infScroll\n        if (_this._infScroll) {\n          _this._infScroll.style.overflow = 'auto';\n          _this._infScroll.style.transform = 'none';\n          _this._infScroll.style.willChange = 'unset';\n        }\n      });\n    };\n    _this.onScrollListener = function (event) {\n      if (typeof _this.props.onScroll === 'function') {\n        // Execute this callback in next tick so that it does not affect the\n        // functionality of the library.\n        setTimeout(function () {\n          return _this.props.onScroll && _this.props.onScroll(event);\n        }, 0);\n      }\n      var target = _this.props.height || _this._scrollableNode ? event.target : document.documentElement.scrollTop ? document.documentElement : document.body;\n      // return immediately if the action has already been triggered,\n      // prevents multiple triggers.\n      if (_this.actionTriggered) return;\n      var atBottom = _this.props.inverse ? _this.isElementAtTop(target, _this.props.scrollThreshold) : _this.isElementAtBottom(target, _this.props.scrollThreshold);\n      // call the `next` function in the props to trigger the next data fetch\n      if (atBottom && _this.props.hasMore) {\n        _this.actionTriggered = true;\n        _this.setState({\n          showLoader: true\n        });\n        _this.props.next && _this.props.next();\n      }\n      _this.lastScrollTop = target.scrollTop;\n    };\n    _this.state = {\n      showLoader: false,\n      pullToRefreshThresholdBreached: false,\n      prevDataLength: props.dataLength\n    };\n    _this.throttledOnScrollListener = throttle(150, _this.onScrollListener).bind(_this);\n    _this.onStart = _this.onStart.bind(_this);\n    _this.onMove = _this.onMove.bind(_this);\n    _this.onEnd = _this.onEnd.bind(_this);\n    return _this;\n  }\n  InfiniteScroll.prototype.componentDidMount = function () {\n    if (typeof this.props.dataLength === 'undefined') {\n      throw new Error(\"mandatory prop \\\"dataLength\\\" is missing. The prop is needed\" + \" when loading more content. Check README.md for usage\");\n    }\n    this._scrollableNode = this.getScrollableTarget();\n    this.el = this.props.height ? this._infScroll : this._scrollableNode || window;\n    if (this.el) {\n      this.el.addEventListener('scroll', this.throttledOnScrollListener);\n    }\n    if (typeof this.props.initialScrollY === 'number' && this.el && this.el instanceof HTMLElement && this.el.scrollHeight > this.props.initialScrollY) {\n      this.el.scrollTo(0, this.props.initialScrollY);\n    }\n    if (this.props.pullDownToRefresh && this.el) {\n      this.el.addEventListener('touchstart', this.onStart);\n      this.el.addEventListener('touchmove', this.onMove);\n      this.el.addEventListener('touchend', this.onEnd);\n      this.el.addEventListener('mousedown', this.onStart);\n      this.el.addEventListener('mousemove', this.onMove);\n      this.el.addEventListener('mouseup', this.onEnd);\n      // get BCR of pullDown element to position it above\n      this.maxPullDownDistance = this._pullDown && this._pullDown.firstChild && this._pullDown.firstChild.getBoundingClientRect().height || 0;\n      this.forceUpdate();\n      if (typeof this.props.refreshFunction !== 'function') {\n        throw new Error(\"Mandatory prop \\\"refreshFunction\\\" missing.\\n          Pull Down To Refresh functionality will not work\\n          as expected. Check README.md for usage'\");\n      }\n    }\n  };\n  InfiniteScroll.prototype.componentWillUnmount = function () {\n    if (this.el) {\n      this.el.removeEventListener('scroll', this.throttledOnScrollListener);\n      if (this.props.pullDownToRefresh) {\n        this.el.removeEventListener('touchstart', this.onStart);\n        this.el.removeEventListener('touchmove', this.onMove);\n        this.el.removeEventListener('touchend', this.onEnd);\n        this.el.removeEventListener('mousedown', this.onStart);\n        this.el.removeEventListener('mousemove', this.onMove);\n        this.el.removeEventListener('mouseup', this.onEnd);\n      }\n    }\n  };\n  InfiniteScroll.prototype.componentDidUpdate = function (prevProps) {\n    // do nothing when dataLength is unchanged\n    if (this.props.dataLength === prevProps.dataLength) return;\n    this.actionTriggered = false;\n    // update state when new data was sent in\n    this.setState({\n      showLoader: false\n    });\n  };\n  InfiniteScroll.getDerivedStateFromProps = function (nextProps, prevState) {\n    var dataLengthChanged = nextProps.dataLength !== prevState.prevDataLength;\n    // reset when data changes\n    if (dataLengthChanged) {\n      return _assign(_assign({}, prevState), {\n        prevDataLength: nextProps.dataLength\n      });\n    }\n    return null;\n  };\n  InfiniteScroll.prototype.isElementAtTop = function (target, scrollThreshold) {\n    if (scrollThreshold === void 0) {\n      scrollThreshold = 0.8;\n    }\n    var clientHeight = target === document.body || target === document.documentElement ? window.screen.availHeight : target.clientHeight;\n    var threshold = parseThreshold(scrollThreshold);\n    if (threshold.unit === ThresholdUnits.Pixel) {\n      return target.scrollTop <= threshold.value + clientHeight - target.scrollHeight + 1;\n    }\n    return target.scrollTop <= threshold.value / 100 + clientHeight - target.scrollHeight + 1;\n  };\n  InfiniteScroll.prototype.isElementAtBottom = function (target, scrollThreshold) {\n    if (scrollThreshold === void 0) {\n      scrollThreshold = 0.8;\n    }\n    var clientHeight = target === document.body || target === document.documentElement ? window.screen.availHeight : target.clientHeight;\n    var threshold = parseThreshold(scrollThreshold);\n    if (threshold.unit === ThresholdUnits.Pixel) {\n      return target.scrollTop + clientHeight >= target.scrollHeight - threshold.value;\n    }\n    return target.scrollTop + clientHeight >= threshold.value / 100 * target.scrollHeight;\n  };\n  InfiniteScroll.prototype.render = function () {\n    var _this = this;\n    var style = _assign({\n      height: this.props.height || 'auto',\n      overflow: 'auto',\n      WebkitOverflowScrolling: 'touch'\n    }, this.props.style);\n    var hasChildren = this.props.hasChildren || !!(this.props.children && this.props.children instanceof Array && this.props.children.length);\n    // because heighted infiniteScroll visualy breaks\n    // on drag down as overflow becomes visible\n    var outerDivStyle = this.props.pullDownToRefresh && this.props.height ? {\n      overflow: 'auto'\n    } : {};\n    return React.createElement(\"div\", {\n      style: outerDivStyle,\n      className: \"infinite-scroll-component__outerdiv\"\n    }, React.createElement(\"div\", {\n      className: \"infinite-scroll-component \" + (this.props.className || ''),\n      ref: function ref(infScroll) {\n        return _this._infScroll = infScroll;\n      },\n      style: style\n    }, this.props.pullDownToRefresh && React.createElement(\"div\", {\n      style: {\n        position: 'relative'\n      },\n      ref: function ref(pullDown) {\n        return _this._pullDown = pullDown;\n      }\n    }, React.createElement(\"div\", {\n      style: {\n        position: 'absolute',\n        left: 0,\n        right: 0,\n        top: -1 * this.maxPullDownDistance\n      }\n    }, this.state.pullToRefreshThresholdBreached ? this.props.releaseToRefreshContent : this.props.pullDownToRefreshContent)), this.props.children, !this.state.showLoader && !hasChildren && this.props.hasMore && this.props.loader, this.state.showLoader && this.props.hasMore && this.props.loader, !this.props.hasMore && this.props.endMessage));\n  };\n  return InfiniteScroll;\n}(Component);\nexport default InfiniteScroll;","import React, { useState, useEffect } from 'react';\r\nimport InfiniteScroll from 'react-infinite-scroll-component';\r\nfunction Lazy_load(props) {\r\n    const [items, setItems] = useState(Array.from({ length: 20 }));\r\n\r\n    const fetchMoreData = () => {\r\n       \r\n        setTimeout(() => {\r\n            setItems(items.concat(Array.from({ length: 10 })));\r\n\r\n        }, 1000)\r\n    };\r\n    const style = {\r\n        height: 18,\r\n        border: \"1px solid green\",\r\n        margin: 6,\r\n        padding: 8\r\n    };\r\n    // console.log(Array.from({ length: 20 }))\r\n    return (\r\n        <div id=\"scrollableDiv\" style={{ height: \"100%\", overflowY: \"scroll\" }}>\r\n            <InfiniteScroll\r\n                dataLength={items.length}\r\n                next={fetchMoreData}\r\n                hasMore={items.length < 200}\r\n                loader={<h4>Loading...</h4>}\r\n                scrollableDiv=\"scrollableDiv\"\r\n            >\r\n                {items.map((i, index) => (\r\n                    <div style={style} key={index}>\r\n                        div - #{index}\r\n                    </div>\r\n                ))}\r\n            </InfiniteScroll>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Lazy_load;"],"sourceRoot":""}